#!/usr/bin/env bash
# FIXME: Cannot get the session type while running sunshine as a systemd service somehow
###########################################################
########### Start user configuration ######################
# TODO: Fetch preferred mode from EDID
# TODO: Multiple monitors support for saving and resuming modes
# TODO: Associate settings to serial number
# TODO: Add niri support using `niri msg output <OUTPUT> <command>`
# Resolution to restore to until default mode and/or mode restore is implemented
_seat_resolution=${DEFAULT_RESOLUTION:-2560x1440}
_seat_refresh_rate=${DEFAULT_REFRESH_RATE:-60}
_default_vrr_mode=automatic
# FIXME: Non-predictable connector name.
_seat_display="DP-1"
_stream_display="HDMI-A-1"
_client_height=${SUNSHINE_CLIENT_HEIGHT:-720}
_client_width=${SUNSHINE_CLIENT_WIDTH:-1280}
_stream_refresh_rate=${SUNSHINE_CLIENT_FPS:-60}
_stream_resolution="${_client_width}x${_client_height}"
# FIXME: Resolution change is fragile on Hypeland
# if [[ -z "$PREFERRED_DISPLAY" ]]; then
# 	PREFERRED_DISPLAY="DP-1"
# fi
# _preferred_monitor_index=1
if ! command -v agrep >/dev/null; then
	echo "agrep not found, cannot continue"
	exit 2
fi
########### End of user configuration #####################
###########################################################
## No configurable values below

_logger=''
log() {
	if [[ -z $_logger ]]; then
		if command -v logger >/dev/null 2>&1; then
			_logger='logger -t dpa'
		else
			_logger='echo'
		fi
	fi
	$_logger "$@" >/proc/self/fd/2
}

# TODO: Save the current VRR mode if it exists to a file to restore it later

# TODO: Organize refactor to do as little work as possible;
# TODO: Find and save available modes as soon as possible
# FIXME: Move this call in the wayland section...

_connector_name_format="DP-"
# # One day, we'll have a bloody standard for connector names...
# if [[ ${_session_type} == "x11" ]]; then
# 	_connector_name_format="DisplayPort-"
# 	_stream_display=HDMI-A-0
# fi
# TODO: Use desktop-specific methods here when possible
# _preferred_monitor=${PREFERRED_DISPLAY:-${_connector_name_format}-${_preferred_monitor_index}}
# TODO: Remove this variable and fix the logic for seat and stream displays
# with proper fallback
_output_to_stream_out=""
# is_dummy_enabled=false
is_there_other_active_displays=false

get_systemd_session_type() {
	# Get systemd session type
	# FIXME: hyprland doesn't show as "active", but as a seat on tty3
	# user_sessions=$(loginctl list_sessions | grep "$USER")
	if [[ -n $XDG_SESSION_TYPE ]]; then
		_session_type="$XDG_SESSION_TYPE"
	else
		# shellcheck disable=SC2312
		_session_type=$(loginctl 2>/dev/null show-session "$(awk '/tty/ {print $1}' <(loginctl list-sessions | grep "$USER" | grep -v manager))" -p Type | awk -F= '{print $2}')
	fi

	if [[ -n $_session_type ]]; then
		echo "$_session_type"
		exit 0
	else
		environment=$(env)
		if grep -qc "WAYLAND_DISPLAY" <<<"$environment"; then
			echo "wayland"
			exit 0
		elif grep -qc "DISPLAY" <<<"$environment"; then
			echo "x11"
			exit 0
		fi
	fi
	echo "none"
}

# TODO: Properly label every step, I'm getting lost
##############################################################################
### DETERMINE THE MAIN COMPUTER DISPLAY
### This value should be different than the dummy plug, UNLESS only the dummy
###    plug is enabled (i.e. monitors off)
if [[ ${XDG_CURRENT_DESKTOP} == "KDE" ]]; then
	log "KDE Mode"
	# shellcheck disable=SC2312
	outputs=$(kscreen-doctor -o | sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2};?)?)?[mGK]//g")
	# transform output into lines, remove disabled outputs, and sort by priority, then return the output to prefer by priority
	# shellcheck disable=SC2312
	p=$(echo "${outputs}" | grep -v "Modes" | grep Output -A4 | xargs | sed 's/Output\:/\n/g' | grep -v disabled | awk '{print $6 " " $7 " " $2}' | sed '/^\s*$/d' | sort | head -n1 | cut -d ' ' -f 3)
	log "primary display: ${p}"
	# shellcheck disable=SC2312
	_output_to_stream_out=$(echo "${outputs}" | /bin/grep -B3 -A0 "${p}" | grep Output: -B0 -A0 | cut -d ' ' -f 3)
	unset p outputs
	# TODO: Make this more readable
elif [[ ${XDG_CURRENT_DESKTOP} == "GNOME" ]]; then
	set -x
	log "echo GNOME Mode"
	_output_to_stream_out=$(gdctl show | grep 'Primary: yes' -A2 | tr -s ' ' | tr -d '└' | tr -d '─' | tail -n1 | cut -d ' ' -f 2)
else
	# is our preferred display enabled?
	set -x
	log "non-KDE Mode"
	if ! command -v wlr-randr; then
		log "Automatic resolution change is not available: wlr-randr not found"
		return
	fi
	# i.e. No need to check for session type if using Hyprland since it's wayland
	# shellcheck disable=SC2312
	# wlr-randr | grep -zoP '(?='"$1"')(?s).*?(?=Adaptive)'

	_session_type=$(get_systemd_session_type)

	# Workaround for missing environment variables when sunshine is running from a systemd unit
	if [[ ${_session_type} == "wayland" ]] && [[ -z $WAYLAND_DISPLAY ]]; then
		export WAYLAND_DISPLAY='wayland-1'
	elif [[ ${_session_type} == "x11" ]]; then
		export DISPLAY=':0'
	elif [[ ${_session_type} == "tty" ]]; then
		log "running in TTY; not performing automation"
		exit 0
	fi
	log "Session type: ${_session_type}"

	if [[ ${_session_type} == "wayland" ]]; then
		if ! command -v wlr-randr; then
			log "Automatic resolution change is not available: wlr-randr not found"
			return
		fi
		# NOTE: wlr-randr has no concept of primary monitor
		# TODO: Make sure we don't disable the only present display
		# if [[ $(wlr-randr | grep -B5 'Enabled: yes' | grep "$_seat_display" -c) -gt 0 ]]; then
		# Check if there is another display enabled beside the dummy plug
		# TODO:
		# shellcheck disable=SC2312
		# FIXME: This works in the terminal but not in the script???
		wlr_randr="$(wlr-randr)"
		# log "wlr-randr: \n${wlr_randr}"
		enabled_connectors=$(echo "${wlr_randr}" | grep --no-group-separator 'Enabled: yes' -B5 | grep -E '(DP|HDMI)-' | cut -d ' ' -f 1)
		log "Enabled Connectors: ${enabled_connectors}"
		if [[ $(echo "${wlr_randr}" | grep --no-group-separator "${_stream_display}" -A5 | grep 'Enabled: yes' -c) -gt 0 ]]; then
			log "Dummy enabled: 1"
			# is_dummy_enabled=true
		else
			log "Dummy enabled: 0"
		fi

		# trunk-ignore(shellcheck/SC2312)
		# FIXME: This is stupid and should not be checked that way
		stream_d=$(echo "${wlr_randr}" | grep -B5 'Enabled: yes' --no-group-separator | grep -v '^\s' | grep "${_stream_display}" | cut -d ' ' -f 1)
		log "Stream Connector: ${stream_d}"
		if [[ $(echo "${stream_d}" | wc -l) -gt 0 ]]; then
			log "Other enabled: 1"
			is_there_other_active_displays=true
		else
			log "Other enabled: 0"
		fi
		if [[ -z ${is_there_other_active_displays} ]]; then
			log "Using the dummy plug"
			_output_to_stream_out=${_stream_display}
		else
			log "Dummy plug is not needed right now"
			log "TODO: Make sure this is actually correct"
			# shellcheck disable=SC2312
			_main_computer_display=$(echo "${stream_d}" | cut -d ' ' -f 1)
		fi
	else
		# TODO: properly handle 'disconnected primary'. Not sure HOW this happens, but I'm staring at it right now.
		# shellcheck disable=SC2312
		_output_to_stream_out=$(xrandr | grep connected -w | awk '{print $1}' | head -n1)
	fi
	# shellcheck disable=SC2312
	# FIXME: This is useful but it currently depends on a varaiable that is not set
	if wlr-randr | grep -A5 "${_output_to_stream_out}" | grep -q 'Enabled: no'; then
		log "WARNING: Primary Monitor was not enabled!!!!!!! Force-enabling dummy plug as a cop-out"
		if [[ ${XDG_CURRENT_DESKTOP} == "Hyprland" ]]; then
			hyprctl keyword monitor "${_stream_display}",enabled
		else
			wlr-randr --output "${_stream_display}" --on
		fi
	fi
fi

# FIXME: Mode change does not work in Hyprland with my main monitor
function wlr_get_available_modes() {
	# shellcheck disable=SC2312
	wlr-randr | grep -zoP '(?='"$1"')(?s).*?(?=Adaptive)'
}
# get_available_modes "DP-1"
function wlr_get_closest_mode() {
	# TODO:use JQ to parse wlr-randr output and get the closest mode that matches
	# wlr-randr --json | jq -j 'map(select(.name == "DP-1"))'
	# TODO: Investigate 'for edid in $(ls /sys/class/drm/*/edid); do echo $edid; edid-decode $edid | grep 'DTD'; done' and 'agrep' for closest matching instead
	# set -x
	log "Request to find closest mode to $*"
	c=$1
	w=$2
	h=$3
	r=$4
	log "${c} ${w} ${h} ${r}"
	# log "running wlr-randr | grep -zoP '(?=$c)(?s).*?(?=Adaptive)'"
	# shellcheck disable=SC2312
	result="$(wlr-randr | grep -zoP '(?=HDMI-A-1)(?s).*?(?=Adaptive)')"
	# log "result=$result"
	closest_rez=$(echo "${result}" | fzf --filter="${w}x${h}")
	# log "closest_rez=$closest_rez"
	closest_hz=$(echo "${closest_rez}" | awk -v c=3 -v t="${r}" 'NR==1{d=$c-t;d=d<0?-d:d;v=$c;next}{m=$c-t;m=m<0?-m:m}m<d{d=m;v=$c}END{print v}')
	# shellcheck disable=SC2312
	result=$(wlr-randr | grep -zoP '(?='"${c}"')(?s).*?(?=Adaptive)' | fzf --filter="""${w}x${h} ${closest_hz}""" | tr -d ' ')
	# TODO: Worth using an array to split instead?
	closest_rez=$(echo "${result}" | cut -d ',' -f 1)
	# shellcheck disable=SC2312
	closest_hz=$(echo "${result}" | cut -d ',' -f 2 | sed 's/Hz//')
	log "Closest match is: ${closest_rez} @ ${closest_hz}"
	_client_height=$(echo "${closest_rez}" | cut -d 'x' -f 2)
	_client_width=$(echo "${closest_rez}" | cut -d 'x' -f 1)
	_refresh="${closest_hz}"
	# set +x
	log "Closest mode for ${_output_to_stream_out}: ${_client_width}x${_client_height}@${_stream_refresh_rate}Hz"
}

get_closest_mode() {
	# TODO: Check if this works in all environments, this might make things easier
	available_modes=$(for edid in /sys/class/drm/card*-"${1}"/edid; do edid-decode "$edid" | grep -E '(DTD|DMT|IBM|Apple)'; done | tr -s ' ' | cut -d ':' -f 2 | cut -d ' ' -f 2-3)
	closest_rez=$(echo "$available_modes" | agrep "${2}")
	rez_match=$(echo "$closest_rez" | agrep --max-errors=4 --max-count=1 "${3}")
	# Fix up extraneous precision causing failure to set the mode
	closest_rez=$(echo "$rez_match" | cut -d ' ' -f 1)
	closest_hz=$(printf '%.3f' "$(echo "$rez_match" | cut -d ' ' -f 2)")
	echo "${closest_rez}@${closest_hz}"
}

###### Set the display modes

log "Assert: PRIMARY:DUMMY == ${_seat_display}:${_stream_display}"
log "Primary output: ${_seat_display}"
if [[ ${_output_to_stream_out} == "" ]]; then
	log "Could not determine output to stream out!!!"
	exit 3
fi
# DEBUG
# get_closest_mode DP-1 2560 1440 60
# TODO: Sanity-check the logic after fixing the confusing variable names
if [[ -n ${_output_to_stream_out} ]]; then
	if [[ $1 == "do" ]]; then
		# TODO: X11 support using xrandr
		if [[ ${XDG_CURRENT_DESKTOP} == "KDE" ]]; then
			# sh -c \"if pgrep plasmashell; then output=`~/scripts/get_primary_monitor`; kscreen-doctor output.${output}.vrrpolicy.never; kscreen-doctor.output.${output}.mode.2560x1440@120; fi\""}]
			# TODO: revisit once KDE has fully native support without Xwayland
			# TODO: Get the available mode that's the closest to the wanted one
			log "Attempting to run 'kscreen-doctor output.${_output_to_stream_out}.mode.${_client_width}x${_client_height}@${_stream_refresh_rate}'"
			kscreen-doctor output."${_output_to_stream_out}".mode."${_client_width}"x"${_client_height}"@"${_stream_refresh_rate}"
			kscreen-doctor output."${_output_to_stream_out}".vrrpolicy.always
		elif [[ ${XDG_CURRENT_DESKTOP} == "GNOME" ]]; then
			log "Detected GNOME"
			# Modern GNOME uses gdctl. I have thoughts about this program...
			gdctl set --logical-monitor --primary --monitor "${_output_to_stream_out}" --mode "$(get_closest_mode "${_output_to_stream_out}" "${_client_width}x${_client_height}" "${_stream_refresh_rate}")"
		elif [[ ${XDG_CURRENT_DESKTOP} == "Hyprland" ]]; then
			log "Detected Hyprland"
			# FIXME: Doesn't seem to work for hyprland
			# wlr_get_closest_mode "${_output_to_stream_out}" "${_client_width}" "${_client_height}" "${_stream_refresh_rate}"
			hyprctl keyword monitor "${_output_to_stream_out}","${_client_width}"x"${_client_height}"@"${_stream_refresh_rate}"
			# if [[ ${_output_to_stream_out} != "$_stream_display" ]]; then
			# 	hyprctl keyword monitor "${_stream_display}",disable
			# fi
		elif [[ ${_session_type} == "wayland" ]]; then
			wlr_get_closest_mode "${_output_to_stream_out} ${_client_width} ${_client_height} ${_stream_refresh_rate}"
			wlr-randr --output "${_output_to_stream_out}" --mode "${_client_width}"x"${_client_height}"@"${_stream_refresh_rate}" --adaptive-sync enabled
		else
			xrandr --output "${_output_to_stream_out}" --mode "${_client_width}"x"${_client_height}" -r "${_stream_refresh_rate}"
		fi
	elif [[ $1 == "undo" ]]; then
		#TODO: Use variation of wlr_get_closest_mode to restore desired resolution
		# TODO: make disabling "$_stream_display" optional
		if [[ ${XDG_CURRENT_DESKTOP} == "KDE" ]]; then
			# TODO: Find preferred mode. it is available through command completion
			kscreen-doctor output."${_output_to_stream_out}".mode."${_seat_resolution}"@"${_seat_refresh_rate}"
			kscreen-doctor output."${_output_to_stream_out}".vrrpolicy."${_default_vrr_mode}"
			if [[ ${_output_to_stream_out} != "${_stream_display}" ]]; then
				kscreen-doctor output."${_stream_display}".disable
			fi
		elif [[ ${XDG_CURRENT_DESKTOP} == "GNOME" ]]; then
			log "WIP"
			gdctl set --logical-monitor --primary --monitor "${_output_to_stream_out}" --mode "$(get_closest_mode "${_output_to_stream_out}" "${_seat_resolution}" "${_seat_refresh_rate}")"
		elif [[ ${XDG_CURRENT_DESKTOP} == "Hyprland" ]]; then
			log "Detected Hyprland"
			if [[ ${_output_to_stream_out} != "${_stream_display}" ]]; then
				# TODO: Save and restore the entry marked as "current"
				hyprctl keyword monitor "${_output_to_stream_out}",preferred
			fi
			# TODO: Only disable dummy plug if not the last display
			# if [[ ${_output_to_stream_out} != "$_stream_display" ]]; then
			# 	hyprctl keyword monitor "${_stream_display}",disable
			# fi
		elif [[ ${_session_type} == "wayland" ]]; then
			wlr-randr --output "${_output_to_stream_out}" --mode "${_seat_resolution}"@"${_seat_refresh_rate}" --adaptive-sync "${_default_vrr_mode}"
			if [[ ${_output_to_stream_out} != "${_stream_display}" ]]; then
				wlr-randr --output "${_stream_display}" --off
			fi
		else
			xrandr --output "${_output_to_stream_out}" --mode "${_seat_resolution}" -r "${_seat_refresh_rate}"
			if [[ ${_output_to_stream_out} != "${_stream_display}" ]]; then
				wlr-randr --output "${_stream_display}" --off
			fi
		fi
	fi
fi
log "Done."
unset _preferred_monitor _session_type _primary _client_height _client_width _refresh

# TODO: COSMIC
# TODO: Hyprland
# FIXME: Make sure dummy plug is enabled on connect. Seems to fail in Hyprland
# TODO: awesomewm, dwm, etc
# TODO: NVIDIA and Intel gpus support

# vim: ft=sh
