#!/usr/bin/env bash
# Modeline {
#	 vi: foldmarker={,} foldmethod=marker foldlevel=0 tabstop=4 filetype=bash
# }
# Logging {
# Log facility from
# https://blog.brujordet.no/post/bash/debugging_bash_like_a_sire/
LOG_LEVEL=${LOG_LEVEL:-1}
function log::level_is_active {
	local check_level current_level
	check_level=$1

	declare -A log_levels=(
		[DEBUG]=1
		[INFO]=2
		[WARN]=3
		[ERROR]=4
	)

	check_level="${log_levels["${check_level}"]}"
	current_level="${log_levels["${LOG_LEVEL}"]}"

	((check_level >= current_level))
}
function log::_write_log {
	# local timestamp file function_name log_level
	local function_name log_level
	log_level=$1
	shift

	if log::level_is_active "${log_level}"; then
		# timestamp=$(date +'%y.%m.%d %H:%M:%S')
		# file="${BASH_SOURCE[2]##*/}"
		function_name="${FUNCNAME[2]}"
		logger "dpa::$(printf '%s [%s]: %s\n' \
			"${log_level}" "${function_name}" "${*}")"

		printf >&2 '%s [%s]: %s\n' \
			"${log_level}" "${function_name}" "${*}"
		# ;;
	fi
}
function log::info {
	log::_write_log "INFO" "$@"
}
function log::warning {
	log::_write_log "WARN" "$@"
}
function log::error {
	log::_write_log "ERROR" "$@"
	local stack_offset=1
	printf '%s:\n' 'Stacktrace:' >&2

	for stack_id in "${!FUNCNAME[@]}"; do
		if [[ ${stack_offset} -le ${stack_id} ]]; then
			local source_file="${BASH_SOURCE[${stack_id}]}"
			local function="${FUNCNAME[${stack_id}]}"
			local line="${BASH_LINENO[$((stack_id - 1))]}"
			printf >&2 '\t%s:%s:%s\n' "${source_file}" "${function}" "${line}"
		fi
	done
}
# }
# Trap errors immediately {
trap 'log::error "[TRAP] An error has occurred"' ERR
# }
# Global Variables {
readonly _seat_resolution=${DEFAULT_RESOLUTION:-1920x1080}
readonly _seat_refresh_rate=${DEFAULT_REFRESH_RATE:-60}
readonly _default_vrr_mode=${DEFAULT_VRR_MODE:-never}
_seat_display=${DEFAULT_SEAT_DISPLAY:=DP-1}
_stream_display=${DEFAULT_STREAM_DISPLAY:=HDMI-A-1}
_client_height=${SUNSHINE_CLIENT_HEIGHT:-720}
_client_width=${SUNSHINE_CLIENT_WIDTH:-1280}
_client_refresh_rate=${SUNSHINE_CLIENT_FPS:-60}
readonly _default_hdr=${DEFAULT_HDR:-disable}
_json_display_config=''
_has_stream_display=false
_has_seat_display=false
# }
function get_connectors_list() {
	for edid in /sys/class/drm/card*-*-*/; do
		case ${edid} in *-Writeback-*) continue ;; *) ;; esac
		edid=${edid%/}        # Remove trailing slash
		edid=${edid##*/}      # Get basename
		echo "${edid#card*-}" # Remove card*- prefix using glob pattern
	done
}
function get_enabled_connectors_list() {
	for edid in /sys/class/drm/card*-*-*/; do
		case ${edid} in *-Writeback-*) continue ;; *) ;; esac
		if [[ "$(<"${edid}/enabled")" == "disabled" ]]; then continue; fi
		edid=${edid%/}        # Remove trailing slash
		edid=${edid##*/}      # Get basename
		echo "${edid#card*-}" # Remove card*- prefix using glob pattern
	done
}
function KDE::get_display_configuration() {
	if [[ -z ${DEFAULT_STREAM_DISPLAY} ]] || [[ -z ${DEFAULT_SEAT_DISPLAY} ]]; then
		log::warning "Please set DEFAULT_STREAM_DISPLAY and DEFAULT_SEAT_DISPLAY"
		log::warning "Automation is a little fragile at the moment"
	fi
}
function KDE::do() {
	if [[ -z ${_stream_display} ]]; then
		log::error "Stream display not set!"
		return 0
	fi
	log::info "Enabling ${_stream_display}"
	kscreen-doctor output."${_stream_display}".enable

	log::info "Configuring ${_stream_display} for streaming"
	adjusted_hz=$(printf '%.0f' "${_client_refresh_rate}")

	# Determine HDR mode
	HDR_MODE=disable
	if [[ ${SUNSHINE_CLIENT_HDR} == "true" ]]; then
		HDR_MODE="enable"
	fi
	log::info "$([[ ${SUNSHINE_CLIENT_HDR} == "true" ]] && echo "Enabling" || echo "Disabling") HDR for ${_stream_display}" || true

	log::info "Setting '${_stream_display}' to ${SUNSHINE_CLIENT_WIDTH}x${SUNSHINE_CLIENT_HEIGHT}@${adjusted_hz}"
	kscreen-doctor output."${_stream_display}".mode."${SUNSHINE_CLIENT_WIDTH}"x"${SUNSHINE_CLIENT_HEIGHT}"@"${adjusted_hz}"
	log::info "Configuring HDR/WCG for ${_stream_display}"
	kscreen-doctor output."${_stream_display}".hdr."${HDR_MODE}" output."${_stream_display}".wcg."${HDR_MODE}"

	# Disable all other displays
	log::info "Waiting before disabling other displays..."
	sleep 1
	local -a all_connectors
	mapfile -t all_connectors < <(get_connectors_list) || true
	for connector in "${all_connectors[@]}"; do
		if [[ ${connector} != "${_stream_display}" ]]; then
			log::info "Disabling ${connector}"
			kscreen-doctor output."${connector}".disable
		fi
	done
}
function KDE::undo() {
	log::info "Restoring ${_seat_display} to default configuration"
	log::info "Enabling ${_seat_display}"
	kscreen-doctor output."${_seat_display}".enable
	log::info "Switching ${_seat_display} to ${_seat_resolution}@${_seat_refresh_rate}"
	kscreen-doctor output."${_seat_display}".mode."${_seat_resolution}"@"${_seat_refresh_rate}"
	log::info "Configuring HDR/WCG/VRR for ${_seat_display}"
	kscreen-doctor output."${_seat_display}".hdr."${_default_hdr}" output."${_seat_display}".wcg."${_default_hdr}" output."${_seat_display}".vrrpolicy."${_default_vrr_mode}"

	# Cache connectors list to avoid repeated subshell spawning
	local -a all_connectors
	mapfile -t all_connectors < <(get_connectors_list) || true

	# Enable and configure other connectors
	for connector in "${all_connectors[@]}"; do
		if [[ ${connector} == "${_stream_display}" ]] && [[ ${_stream_display} != "${_seat_display}" ]]; then
			log::info "Skipping stream display ${connector}"
			continue
		fi
		if [[ ${connector} != "${_seat_display}" ]]; then
			log::info "Enabling ${connector}"
			kscreen-doctor output."${connector}".enable
		fi
	done
	# Disable stream output last
	if [[ ${_stream_display} != "${_seat_display}" ]]; then
		log::info "Waiting before disabling stream display..."
		sleep 1
		log::info "Disabling ${_stream_display}"
		kscreen-doctor output."${_stream_display}".disable
	else
		log::info "Not doing anything else because Stream Display isn't different than Seat display (${_stream_display} != ${_seat_display})"
	fi
}
function niri::get_display_configuration() {
	_json_display_config=$(niri msg -j outputs)
	mapfile -t outputs_list < <(echo "${_json_display_config}" | jq -r '.[] | .name')
	log::info "outputs_list: ${outputs_list[*]}"
	if echo "${_json_display_config}" | jq "has(\"${_stream_display}\")"; then
		_has_stream_display=true
	fi
	if echo "${_json_display_config}" | jq "has(\"${_seat_display}\")"; then
		_has_seat_display=true
	fi
	log::info "Stream Display Present: ${_has_stream_display}"
	log::info "Seat   Display Present: ${_has_seat_display}"
}
function niri::do() {
	# Niri is fickle, let's be extremely explicit about the behavior we want.
	if [[ ${_has_stream_display} == "true" ]] && [[ ${_has_seat_display} == "false" ]]; then
		# Only the stream display is present
		log::info "Only stream display is present, moving over to stream display ${_stream_display}"
		niri msg output "${_stream_display}" on
		niri msg output "${_stream_display}" mode "${_client_width}x${_client_height}"
		niri msg output "${_stream_display}" position "0x0"
	elif [[ ${_has_stream_display} == "false" ]] && [[ ${_has_seat_display} == "true" ]]; then
		# Only the seat display is present
		log::info "Only seat display is present, moving over to seat display ${_seat_display}"
		niri msg output "${_seat_display}" on
		niri msg output "${_seat_display}" mode "${_client_width}x${_client_height}"
		niri msg output "${_seat_display}" position "0x0"
	elif [[ ${_has_stream_display} == "true" ]] && [[ ${_has_seat_display} == "true" ]]; then
		# Both displays are present
		log::info "Both displays are present, switching over to stream display ${_stream_display}"
		niri msg output "${_stream_display}" on
		niri msg output "${_stream_display}" mode "${_client_width}x${_client_height}"
		niri msg output "${_stream_display}" position "0x0"
		niri msg action focus-monitor "${_stream_display}"
		niri msg action focus-workspace 1
		log::info "Disabling ${_seat_display}"
		niri msg output "${_seat_display}" off
	elif [[ ${_has_stream_display} == "false" ]] && [[ ${_has_seat_display} == "false" ]]; then
		# No display are present
		log::warning "No display has been found, automation skipped!"
	fi
	log::info "Done"
}
function niri::undo() {
	# Niri is fickle, let's be extremely explicit about the behavior we want.
	if [[ ${_has_stream_display} == "true" ]] && [[ ${_has_seat_display} == "false" ]]; then
		# Only the stream display is present
		log::info "Only stream display is present, moving over to stream display ${_stream_display}"
		niri msg output "${_stream_display}" on
		niri msg output "${_stream_display}" mode "${_seat_resolution}"
		niri msg output "${_stream_display}" position "0x0"
	elif [[ ${_has_stream_display} == "false" ]] && [[ ${_has_seat_display} == "true" ]]; then
		# Only the seat display is present
		log::info "Only seat display is present, moving over to seat display ${_seat_display}"
		niri msg output "${_seat_display}" on
		niri msg output "${_seat_display}" mode "${_seat_resolution}"
		niri msg output "${_seat_display}" position "0x0"
	elif [[ ${_has_stream_display} == "true" ]] && [[ ${_has_seat_display} == "true" ]]; then
		# Both displays are present
		log::info "Both displays are present, switching over to seat display ${_seat_display}"
		niri msg output "${_seat_display}" on
		niri msg output "${_seat_display}" mode "${_seat_resolution}"
		niri msg output "${_seat_display}" position "0x0"
		niri msg action focus-monitor "${_seat_display}"
		niri msg action focus-workspace 1
		log::info "Disabling ${_stream_display}"
		niri msg output "${_stream_display}" off
	elif [[ ${_has_stream_display} == "false" ]] && [[ ${_has_seat_display} == "false" ]]; then
		# No display are present
		log::warning "No display has been found, automation skipped!"
	fi
	log::info "Done"
}
function mainloop() {
	log::info "Global variables at start:
  _seat_resolution=${_seat_resolution}
  _seat_refresh_rate=${_seat_refresh_rate}
  _default_vrr_mode=${_default_vrr_mode}
  _seat_display=${_seat_display}
  _stream_display=${_stream_display}
  _client_height=${_client_height}
  _client_width=${_client_width}
  _client_refresh_rate=${_client_refresh_rate}
  _default_hdr=${_default_hdr}
  XDG_CURRENT_DESKTOP=${XDG_CURRENT_DESKTOP}
  XDG_SESSION_DESKTOP=${XDG_SESSION_DESKTOP}
  "

	case "${XDG_CURRENT_DESKTOP}" in
	"GNOME" | "KDE" | "niri")
		"${XDG_CURRENT_DESKTOP}::get_display_configuration"
		# "${XDG_CURRENT_DESKTOP}::get_closest_mode"
		"${XDG_CURRENT_DESKTOP}::$1"
		;;
	*)
		if [[ -n ${XDG_CURRENT_DESKTOP} ]]; then
			log::error "Desktop environment '${XDG_CURRENT_DESKTOP}' is not supported"
		else
			log::error "XDG_CURRENT_DESKTOP is not set!"
		fi
		log::error "Cannot apply automation: no desktop environment handler available"
		exit 0
		;;
	esac
	if [[ ${_stream_display} == "" ]]; then
		log::error "Could not determine output to stream out!!!"
		exit 0
	fi

	unset _preferred_monitor _session_type _primary _client_height _client_width _refresh
	# log::info "Reminder: If your client gets a black screen, try rebooting the host"
}
mainloop "$@"
