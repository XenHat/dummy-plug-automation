#!/usr/bin/env bash
# TODOs and FIXMEs {
#TODO: Properly label every step, I'm getting lost
#TODO: re-implement COSMIC
#TODO: re-implement hyprland
# TODO: re-implement automatic display switching, make it optional first
#FIXME: Make sure dummy plug is enabled on connect. Seems to fail in Hyprland
#TODO: test X11 for awesomewm, dwm, etc
#TODO: NVIDIA and Intel gpus support
#TODO: Fetch preferred mode from EDID
#TODO: Multiple monitors support for saving and resuming modes
#TODO: Associate settings to serial number
#TODO: Add niri support using `niri msg output <OUTPUT> <command>`
#FIXME: Non-predictable connector name.
#FIXME: Resolution change is fragile on Hyprland
#TODO: Save the current VRR mode if it exists to a file to restore it later
#TODO: Organize refactor to do as little work as possible;
#TODO: Find and save available modes as soon as possible
#TODO: Standardize behavior between desktop environments WRT seat display being present
#TODO: rework code to not assume the dummy plug is HDMI. There are some DisplayPort ones.
#FIXME: Automatic resolution picking is currently broken. Will apply as is.
#
# }
_enable_auto_res_fallback=false
# Logging {
# Log facility from
# https://blog.brujordet.no/post/bash/debugging_bash_like_a_sire/
LOG_LEVEL=${LOG_LEVEL:-1}
function log::_write_log {
  local timestamp file function_name log_level
  log_level=$1
  shift

  if log::level_is_active "${log_level}"; then
    timestamp=$(date +'%y.%m.%d %H:%M:%S')
    file="${BASH_SOURCE[2]##*/}"
    function_name="${FUNCNAME[2]}"
      logger "dpa::$(printf '%s [%s] [%s - %s]: %s\n' \
        "${log_level}" "${timestamp}" "${file}" "${function_name}" "${*}")"

      printf >&2 '%s [%s] [%s - %s]: %s\n' \
        "${log_level}" "${timestamp}" "${file}" "${function_name}" "${*}"
      # ;;
  fi
}
function log::info {
  log::_write_log "INFO" "$@"
}
function log::warning {
  log::_write_log "WARN" "$@"
}
function log::level_is_active {
  local check_level current_level
  check_level=$1

  declare -A log_levels=(
    [DEBUG]=1
    [INFO]=2
    [WARN]=3
    [ERROR]=4
  )

  check_level="${log_levels["${check_level}"]}"
  current_level="${log_levels["${LOG_LEVEL}"]}"

  ((check_level >= current_level))
}
function log::error {
  log::_write_log "ERROR" "$@"
  local stack_offset=1
  printf '%s:\n' 'Stacktrace:' >&2

  for stack_id in "${!FUNCNAME[@]}"; do
    if [[ ${stack_offset} -le ${stack_id} ]]; then
      local source_file="${BASH_SOURCE[${stack_id}]}"
      local function="${FUNCNAME[${stack_id}]}"
      local line="${BASH_LINENO[$((stack_id - 1))]}"
      printf >&2 '\t%s:%s:%s\n' "${source_file}" "${function}" "${line}"
    fi
  done
}
# }
# Trap errors immediately {
trap 'log::error "[TRAP] An error has occurred"' ERR
# }
# Dependencies {
if _enable_auto_res_fallback && ! command -v agrep >/dev/null; then
  message="agrep not found, cannot continue"
  log::error "${message}"
  exit 2
fi
# }
# Global Variables {
is_there_other_active_displays=false
_seat_resolution=${DEFAULT_RESOLUTION:-2560x1440}
_seat_refresh_rate=${DEFAULT_REFRESH_RATE:-60}
_default_vrr_mode=${DEFAULT_VRR_MODE:-automatic}
_seat_display=${DEFAULT_SEAT_DISPLAY:=DP-1}
_stream_display=${DEFAULT_STREAM_DISPLAY:=HDMI-A-1}
_client_height=${SUNSHINE_CLIENT_HEIGHT:-720}
_client_width=${SUNSHINE_CLIENT_WIDTH:-1280}
_client_refresh_rate=${SUNSHINE_CLIENT_FPS:-60}
_client_best_size=""
# }
# Common functions {
get_systemd_session_type() {
  # Get systemd session type
  #FIXME: hyprland doesn't show as "active", but as a seat on tty3
  # user_sessions=$(loginctl list_sessions | grep "$USER")
  if [[ -n $XDG_SESSION_TYPE ]]; then
    _session_type="$XDG_SESSION_TYPE"
  else
    # shellcheck disable=SC2312
    _session_type=$(
      loginctl 2>/dev/null show-session \
        "$(awk '/tty/ {print $1}' <(loginctl list-sessions |
        grep "$USER" |
        grep -v manager))" -p Type | awk -F= '{print $2}'
      )
  fi

  if [[ -n $_session_type ]]; then
    echo "$_session_type"
    exit 0
  else
    environment=$(env)
    if grep -qc "WAYLAND_DISPLAY" <<<"$environment"; then
      echo "wayland"
      exit 0
    elif grep -qc "DISPLAY" <<<"$environment"; then
      echo "x11"
      exit 0
    fi
  fi
  echo "none"
}
get_connectors_list() {
  for edid in /sys/class/drm/card*-*-*/; do
    case ${edid} in *-Writeback-*) continue ;; esac
    basename "${edid}" | sed 's/card[0-9]*\-//'
  done
}
get_enabled_connectors_list() {
  for edid in /sys/class/drm/card*-*-*/; do
    case ${edid} in *-Writeback-*) continue ;; esac
    if [[ "$(< "$edid/enabled")" == "disabled" ]]; then continue; fi
    basename "${edid}" | sed 's/card[0-9]*\-//'
  done
}
# }
# KDE Desktop {
function KDE::get_display_configuration() {
  enabled_connectors=$(get_enabled_connectors_list)
  log::warning "Enabled Connectors: ${#enabled_connectors[@]} ($enabled_connectors)"

  if [[ ${#enabled_connectors[@]} -lt 2 ]]; then
    _stream_display=${enabled_connectors[0]}
    _seat_display=${enabled_connectors[0]}
  fi
  log::warning "New stream display: $_stream_display"
  outputs=$(kscreen-doctor --json | jq -r '.outputs[].name' | xargs)
  log::warning "Displays: $outputs"
  # transform output into lines, remove disabled outputs, and sort by priority,
  # then return the output to prefer by priority
  # shellcheck disable=SC2312
  if grep "$_seat_display" <<< "$enabled_connectors"; then
    log::warning "Seat display '$_seat_display' found"
  else
    log::warning "Seat display'$_seat_display'  NOT found"
  fi
  if grep "$_stream_display" <<< "$enabled_connectors"; then
    log::warning "Stream display '$_stream_display' found"
  else
    log::warning "Stream display '$_stream_display' NOT found"
  fi
  if eval "$(kscreen-doctor --json | jq -r '.outputs[] | select(.name == "'"$_seat_display"'") | .enabled')"; then
    log::warning "Seat display is enabled"
  fi
  if eval "$(kscreen-doctor --json | jq -r '.outputs[] | select(.name == "'"$_stream_display"'") | .enabled')"; then
    log::warning "Stream display is enabled"
  fi
}

function KDE::get_closest_mode() {
  #TODO: Get supported modes via kscreen-doctor instead as it lists and allows more
  get_closest_mode
}
function KDE::do() {
  log::info "Finish Me"
  if [[ "$_stream_display" == "$_seat_display" ]]; then
    adjusted_hz=$(printf '%.0f' "$_client_refresh_rate")
    log::info "Attempting kscreen-doctor output.${_stream_display}.mode.${SUNSHINE_CLIENT_WIDTH}x${SUNSHINE_CLIENT_HEIGHT}@${adjusted_hz}"
    kscreen-doctor output."${_stream_display}".mode."${SUNSHINE_CLIENT_WIDTH}"x"${SUNSHINE_CLIENT_HEIGHT}"@"${adjusted_hz}"
  fi
}
function KDE::undo() {
  log::info "Finish Me"
  for connector in $(get_connectors_list); do
    if [[ ${connector} == "${_stream_display}" ]] && [[ "${_stream_display}" != "${_seat_display}" ]]; then
      log::info "Skipping over ${connector}"
      continue
    fi
    if [[ ${connector} == "${_seat_display}" ]]; then
      log::info "Handling Seat display ${connector}"
      kscreen-doctor output."${connector}".mode."${_seat_resolution}"@"${_seat_refresh_rate}"
      kscreen-doctor output."${connector}.vrrpolicy.${_default_vrr_mode}"
    fi
    log::info "Enabling ${connector}"
    kscreen-doctor output."${connector}".enable
  done
  # Disable stream output last
  if [[ ${_stream_display} != "${_seat_display}" ]]; then
    log::info "Disabling ${_stream_display}"
    kscreen-doctor output."${_stream_display}".disable
  fi
}
# }
# GNOME Desktop {
function GNOME::get_display_configuration() {
  _stream_display=$(gdctl show |
    grep 'Primary: yes' -A2 |
    tr -s ' ' |
    tr -d '└' |
    tr -d '─' |
    tail -n1 |
    cut -d ' ' -f 2)
  }
# Format: <who> <what>@<Hz>
function GNOME::set() {
  log::info "Setting '$1' to '$2'"
  gdctl set --logical-monitor --primary --monitor "$1" --mode "$2"
}
function GNOME::get_closest_mode() {
  get_closest_mode
}
function GNOME::do() {
  for connector in $(get_enabled_connectors_list); do
    connector=${connector/HDMI-A-/HDMI-}
    log::info "connector: '$connector'"
    if [[ "$connector" == "$_stream_display" ]]; then
      result=$(get_closest_mode "$connector" "${_client_width}x${_client_height}" "${_client_refresh_rate}")
      adjusted_hz=$(printf '%.3f' "$_client_refresh_rate")
      log::info "Adjusting refresh rate from '$_client_refresh_rate' to '$adjusted_hz'"
      GNOME::set  "$connector" "${_client_best_size}@${adjusted_hz}"
      #TODO: Properly disable monitors
      # else
      # log::info "Disabling $connector"
      # gdctl --logical-monitor --monitor "$1" --mode "$2"
    else
      log::warning "Uh..... What to do with '$connector'?"
    fi
  done 
}
function GNOME::undo() {
  log::info "Finish Me"
  for connector in $(get_connectors_list); do
    log::info "Handling connector '$connector'"
    connector=${connector/HDMI-A-/HDMI-}
    if [[ "$connector" == "$_seat_display" ]]; then
      result=$(get_closest_mode "$connector" "${_seat_resolution}" "${_seat_refresh_rate}")
      adjusted_hz=$(printf '%.3f' "$_seat_refresh_rate")
      log::info "Adjusting refresh rate from '$_seat_refresh_rate' to '$adjusted_hz'"
      log::info "Setting '$connector' to '${_seat_resolution}@${adjusted_hz}'"
      GNOME::set  "$connector" "${_seat_resolution}@${adjusted_hz}"
    else
      log::warning "Finish implementing this display: '$connector'"
      #FIXME: Restore multi-monitor setup
      #FIXME: requires upcoming generic get_closest_mode
      # GNOME::set $(get_generic_mode "$DEFAULT_RESOLUTION" "$DEFAULT_REFRESH_RATE")
      # 
      # if [[ "$DEFAULT_VRR_MODE" == "automatic" ]] || [[ "$DEFAULT_VRR_MODE" == "enabled" ]]; then

      # GNOME::set "$connector" "${DEFAULT_RESOLUTION}@${DEFAULT_REFRESH_RATE}+vrr"
      # else
      #adjusted_hz=$(printf '%.3f' "${DEFAULT_REFRESH_RATE}")
      # GNOME::set "$connector" "2560x1440@59.951"
      # fi
    fi
  done 
  GNOME::set "$"
}
# }
# Niri Window Manager {
function niri::get_display_configuration() {
  _stream_resolution=${SUNSHINE_CLIENT_WIDTH}x${SUNSHINE_CLIENT_HEIGHT}
  _stream_refresh_rate=${SUNSHINE_CLIENT_FPS}
  log::info "Stream resolution:   $_stream_resolution"
  log::info "Stream refresh rate: $_stream_refresh_rate"
}
function niri::do() {

  log::info "Performing niri logic"
  _stream_display=$_seat_display
  niri msg output "${_stream_display}" mode "${_stream_resolution}"
}
function niri::undo() {
  niri msg output "${_stream_display}" on
  niri msg output "${_stream_display}" mode "${DEFAULT_RESOLUTION}"
}
# }
# Main logic {
mainloop() {
  log::warning "Program Start"
  log::warning "Automatic resolution picking is currently broken. Stream settings will be applied as-is regardless of monitor support."
  # is_dummy_enabled=false

  # Print the startup state {
  log::info "Global variables at start:
  _seat_resolution=$_seat_resolution
  _seat_refresh_rate=$_seat_refresh_rate
  _default_vrr_mode=$_default_vrr_mode
  _seat_display=$_seat_display
  _stream_display=$_stream_display
  _client_height=$_client_height
  _client_width=$_client_width
  _client_refresh_rate=$_client_refresh_rate
  _client_best_size=$_client_best_size
  "
  # }


  case "$XDG_CURRENT_DESKTOP" in
    "GNOME"|"KDE"|"niri")
      "${XDG_CURRENT_DESKTOP}::get_display_configuration"
      "${XDG_CURRENT_DESKTOP}::$1"
      ;;
    *)
      log::info "Entering generic environment methods"
      get_display_configuration
      get_closest_mode
      set_display_mode "$1"
      ;;
  esac
  #FIXME: This will sometimes report 'Assert: PRIMARY:DUMMY == DP-1:DP-2' which
  # is wrong. Should be DP2:HDMI-A-1
  # log::info "Assert: PRIMARY:DUMMY == ${_seat_display}:${_stream_display}"
  #FIXME: This often reports the wrong connector i.e. DP-1 instead of DP-2
  log::info "Seat display:   ${_seat_display}"
  log::info "Stream display: ${_stream_display}"
  if [[ ${_stream_display} == "" ]]; then
    log::info "Could not determine output to stream out!!!"
    exit 3
  fi

  # Set the preferred monitor for WINE's wayland driver
  WAYLANDDRV_PRIMARY_MONITOR=${_stream_display}
  export WAYLANDDRV_PRIMARY_MONITOR

  unset _preferred_monitor _session_type _primary _client_height _client_width _refresh
  log::warning "Program End"
}
mainloop "$@"
# }
# Modeline {
#	 vi: foldmarker={,} foldmethod=marker foldlevel=0 tabstop=4 filetype=bash
# }
